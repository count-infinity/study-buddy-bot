[
  {
    "quiz_id": "variables_b_1",
    "topic": "variables",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "Which of the following is a valid Python variable name?",
    "options": {"A": "2nd_place", "B": "my-var", "C": "_count", "D": "class"},
    "correct_answer": "C",
    "explanation": "_count is valid because Python variable names can start with a letter or underscore. They cannot start with a digit (A), contain hyphens (B), or be reserved keywords like 'class' (D).",
    "hint_1": "Think about what characters are allowed at the start of a variable name.",
    "hint_2": "Variable names can begin with letters or underscores, but not digits or special characters.",
    "hint_3": "The one starting with an underscore is the only legal option."
  },
  {
    "quiz_id": "variables_b_2",
    "topic": "variables",
    "difficulty": "beginner",
    "question_type": "short_answer",
    "question": "What is the term for the operation `x = 10` in Python?",
    "correct_answer": "assignment",
    "explanation": "Using the = operator to bind a value to a variable name is called assignment. It stores the value 10 in the variable x.",
    "hint_1": "It is a fundamental operation that gives a name to a value.",
    "hint_2": "The = symbol is called the ______ operator.",
    "hint_3": "It rhymes with 'a-sign-ment'."
  },
  {
    "quiz_id": "variables_b_3",
    "topic": "variables",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nx = 5\ny = x\nx = 10\nprint(y)\n```",
    "correct_answer": "5",
    "explanation": "When y = x is executed, y gets the current value of x, which is 5. Changing x later to 10 does not affect y because integers are immutable and y holds its own copy of the value.",
    "hint_1": "Think about whether y is linked to x or to the value x held at the time of assignment.",
    "hint_2": "In Python, assigning an integer creates an independent copy of the value for the new variable.",
    "hint_3": "y was assigned when x was 5, and reassigning x does not change y."
  },
  {
    "quiz_id": "variables_b_4",
    "topic": "variables",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "What will happen if you try to use a variable that has not been defined yet?",
    "options": {"A": "It will default to 0", "B": "It will default to None", "C": "A NameError will be raised", "D": "A TypeError will be raised"},
    "correct_answer": "C",
    "explanation": "Python raises a NameError when you reference a variable that has not been assigned a value. Unlike some other languages, Python does not auto-initialize variables.",
    "hint_1": "Python does not silently create variables for you.",
    "hint_2": "An error is raised, and the error type relates to the 'name' not being found.",
    "hint_3": "The specific exception is NameError."
  },
  {
    "quiz_id": "variables_b_5",
    "topic": "variables",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\na, b, c = 1, 2, 3\nprint(b)\n```",
    "correct_answer": "2",
    "explanation": "Python supports multiple assignment (tuple unpacking). The values 1, 2, 3 are assigned to a, b, c respectively, so b gets the value 2.",
    "hint_1": "Each variable on the left gets a corresponding value from the right.",
    "hint_2": "The second variable receives the second value.",
    "hint_3": "b is assigned the value 2."
  },
  {
    "quiz_id": "variables_i_1",
    "topic": "variables",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nx = [1, 2, 3]\ny = x\ny.append(4)\nprint(x)\n```",
    "correct_answer": "[1, 2, 3, 4]",
    "explanation": "Lists are mutable objects. When y = x is executed, both y and x reference the same list object in memory. Modifying the list through y also affects x because they point to the same object.",
    "hint_1": "Think about how mutable objects are handled during assignment.",
    "hint_2": "With lists, y = x does not create a copy; both names refer to the same object.",
    "hint_3": "Since x and y share the same list, appending 4 via y means x also shows [1, 2, 3, 4]."
  },
  {
    "quiz_id": "variables_i_2",
    "topic": "variables",
    "difficulty": "intermediate",
    "question_type": "multiple_choice",
    "question": "What does the `global` keyword do inside a function?",
    "options": {"A": "Creates a new global variable that only exists during the function call", "B": "Allows the function to read and modify a variable defined at module level", "C": "Makes the variable accessible to all imported modules", "D": "Prevents the variable from being garbage collected"},
    "correct_answer": "B",
    "explanation": "The global keyword tells Python that a variable inside a function refers to the module-level (global) variable rather than creating a new local variable. This allows both reading and modifying the global variable.",
    "hint_1": "It changes which scope a variable name refers to.",
    "hint_2": "Without it, assigning to a variable inside a function creates a local variable.",
    "hint_3": "It lets you modify a module-level variable from within a function."
  },
  {
    "quiz_id": "variables_i_3",
    "topic": "variables",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\na = 5\nb = 3\na, b = b, a\nprint(a, b)\n```",
    "correct_answer": "3 5",
    "explanation": "Python evaluates the entire right side of the assignment before assigning to the left. The expression b, a creates a tuple (3, 5) first, then unpacks it into a and b, effectively swapping their values.",
    "hint_1": "This is a common Python idiom for a specific operation.",
    "hint_2": "The right-hand side is fully evaluated before any assignment happens.",
    "hint_3": "The values of a and b are swapped: a becomes 3, b becomes 5."
  },
  {
    "quiz_id": "variables_i_4",
    "topic": "variables",
    "difficulty": "intermediate",
    "question_type": "short_answer",
    "question": "In Python, what built-in function returns the unique memory address (identity) of an object that a variable references?",
    "correct_answer": "id",
    "explanation": "The id() function returns the identity of an object, which is its memory address in CPython. It is useful for checking whether two variables refer to the exact same object in memory.",
    "hint_1": "It is a very short function name.",
    "hint_2": "It is a two-letter built-in function.",
    "hint_3": "The function is id()."
  },
  {
    "quiz_id": "variables_i_5",
    "topic": "variables",
    "difficulty": "intermediate",
    "question_type": "multiple_choice",
    "question": "Which statement about Python's augmented assignment `x += 1` is true?",
    "options": {"A": "It is always identical to x = x + 1 for every type", "B": "For mutable types like lists, += modifies the object in place", "C": "It can only be used with numeric types", "D": "It creates a new variable named x+"},
    "correct_answer": "B",
    "explanation": "For mutable types like lists, += calls __iadd__ which modifies the object in place. For immutable types like integers, += still creates a new object (like x = x + 1). So the behavior differs by type.",
    "hint_1": "Consider how += behaves differently on mutable vs immutable objects.",
    "hint_2": "Lists have an __iadd__ method that modifies them in place.",
    "hint_3": "For lists, += extends the existing list rather than creating a new one."
  },
  {
    "quiz_id": "variables_a_1",
    "topic": "variables",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef f():\n    print(x)\n\nx = 10\nf()\nx = 20\nf()\n```",
    "correct_answer": "10\n20",
    "explanation": "The function f() does not have a local variable x, so it looks up x in the global scope each time it is called. The first call finds x = 10, the second call finds x = 20 because global variable lookup happens at call time, not at function definition time.",
    "hint_1": "Consider when the global variable x is looked up.",
    "hint_2": "Python resolves free variables at the time the function is called, not when it is defined.",
    "hint_3": "Each call to f() reads the current value of the global x at that moment."
  },
  {
    "quiz_id": "variables_a_2",
    "topic": "variables",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x += 5\n        return x\n    return inner(), x\n\nprint(outer())\n```",
    "correct_answer": "(15, 15)",
    "explanation": "The nonlocal keyword allows inner() to modify the x variable from the enclosing outer() scope. After inner() runs, x is changed to 15 in outer's scope. So inner() returns 15, and x in outer is also 15, producing (15, 15).",
    "hint_1": "The nonlocal keyword creates a connection to the enclosing function's variable.",
    "hint_2": "After inner() modifies x, the change is visible in outer() as well.",
    "hint_3": "Both the return value of inner() and x in outer are 15 after the modification."
  },
  {
    "quiz_id": "variables_a_3",
    "topic": "variables",
    "difficulty": "advanced",
    "question_type": "multiple_choice",
    "question": "What happens when you execute the following code?\n\n```python\ndef f():\n    print(x)\n    x = 5\nf()\n```",
    "options": {"A": "It prints None then sets x to 5", "B": "It prints the global value of x if one exists", "C": "It raises an UnboundLocalError", "D": "It raises a SyntaxError"},
    "correct_answer": "C",
    "explanation": "Python determines at compile time that x is a local variable because it is assigned within the function. However, the print(x) line tries to read x before it has been assigned a value locally, causing an UnboundLocalError.",
    "hint_1": "Python decides whether a variable is local or global at compile time, not runtime.",
    "hint_2": "The assignment x = 5 makes Python treat x as local throughout the entire function body.",
    "hint_3": "Reading a local variable before it is assigned raises UnboundLocalError."
  },
  {
    "quiz_id": "variables_a_4",
    "topic": "variables",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nimport copy\na = [[1, 2], [3, 4]]\nb = copy.copy(a)\nb[0].append(5)\nb[1] = [6, 7]\nprint(a)\nprint(b)\n```",
    "correct_answer": "[[1, 2, 5], [3, 4]]\n[[1, 2, 5], [6, 7]]",
    "explanation": "copy.copy() creates a shallow copy. The outer list is a new object, but the inner lists are still shared references. b[0].append(5) mutates the shared inner list (affecting both a and b). b[1] = [6, 7] replaces the reference in b only, leaving a[1] unchanged.",
    "hint_1": "Think about the difference between shallow and deep copies.",
    "hint_2": "A shallow copy duplicates the outer container but shares references to nested objects.",
    "hint_3": "Mutating a shared inner list affects both, but reassigning an element in the outer list only affects the copy."
  },
  {
    "quiz_id": "variables_a_5",
    "topic": "variables",
    "difficulty": "advanced",
    "question_type": "short_answer",
    "question": "In CPython, small integers in the range -5 to 256 are cached and reused. What is this optimization called?",
    "correct_answer": "integer interning",
    "explanation": "CPython pre-allocates and caches small integers (from -5 to 256) so that every reference to the same small integer points to the same object. This is called integer interning (or integer caching) and is done for performance optimization.",
    "hint_1": "It is an optimization that avoids creating duplicate objects for frequently used values.",
    "hint_2": "The word describes the practice of storing and reusing a single copy of a value.",
    "hint_3": "The term is 'integer interning' or 'integer caching'."
  },
  {
    "quiz_id": "data_types_b_1",
    "topic": "data_types",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "What is the data type of the value `3.14` in Python?",
    "options": {"A": "int", "B": "float", "C": "double", "D": "decimal"},
    "correct_answer": "B",
    "explanation": "In Python, any number written with a decimal point is a float (floating-point number). Python does not have a 'double' type like C/Java; all floating-point numbers are float.",
    "hint_1": "It is one of Python's built-in numeric types.",
    "hint_2": "Numbers with decimal points are not integers.",
    "hint_3": "The type is float."
  },
  {
    "quiz_id": "data_types_b_2",
    "topic": "data_types",
    "difficulty": "beginner",
    "question_type": "short_answer",
    "question": "What built-in function do you use to find out the data type of a value or variable in Python?",
    "correct_answer": "type",
    "explanation": "The type() function returns the type of an object. For example, type(42) returns <class 'int'> and type('hello') returns <class 'str'>.",
    "hint_1": "It is a very common built-in function.",
    "hint_2": "The function name is a four-letter word that means 'kind' or 'category'.",
    "hint_3": "The function is type()."
  },
  {
    "quiz_id": "data_types_b_3",
    "topic": "data_types",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nprint(type(True).__name__)\n```",
    "correct_answer": "bool",
    "explanation": "True is a boolean value in Python. The type() function returns <class 'bool'>, and __name__ extracts just the type name as a string, which is 'bool'.",
    "hint_1": "True and False are values of a specific built-in type.",
    "hint_2": "The type name is short for 'boolean'.",
    "hint_3": "The answer is 'bool'."
  },
  {
    "quiz_id": "data_types_b_4",
    "topic": "data_types",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "Which of the following creates a string in Python?",
    "options": {"A": "x = 'hello'", "B": "x = \"hello\"", "C": "x = '''hello'''", "D": "All of the above"},
    "correct_answer": "D",
    "explanation": "Python allows strings to be defined with single quotes, double quotes, or triple quotes (single or double). All three forms produce the same string type.",
    "hint_1": "Python is flexible about how you delimit strings.",
    "hint_2": "There are multiple valid syntaxes for creating strings in Python.",
    "hint_3": "Single quotes, double quotes, and triple quotes all create strings."
  },
  {
    "quiz_id": "data_types_b_5",
    "topic": "data_types",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nprint(int(\"42\") + int(\"8\"))\n```",
    "correct_answer": "50",
    "explanation": "The int() function converts the string '42' to the integer 42, and '8' to the integer 8. Adding them yields 50.",
    "hint_1": "int() converts strings to integers.",
    "hint_2": "After conversion, you are adding two integers: 42 + 8.",
    "hint_3": "42 + 8 = 50."
  },
  {
    "quiz_id": "data_types_i_1",
    "topic": "data_types",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nprint(0.1 + 0.2 == 0.3)\n```",
    "correct_answer": "False",
    "explanation": "Due to floating-point representation in binary, 0.1 + 0.2 does not equal exactly 0.3. The actual result is approximately 0.30000000000000004, so the equality comparison returns False.",
    "hint_1": "Floating-point arithmetic has some well-known surprises.",
    "hint_2": "Computers represent decimals in binary, which can introduce tiny rounding errors.",
    "hint_3": "0.1 + 0.2 is actually 0.30000000000000004 in Python, not exactly 0.3."
  },
  {
    "quiz_id": "data_types_i_2",
    "topic": "data_types",
    "difficulty": "intermediate",
    "question_type": "multiple_choice",
    "question": "Which of the following data types is mutable in Python?",
    "options": {"A": "tuple", "B": "str", "C": "dict", "D": "frozenset"},
    "correct_answer": "C",
    "explanation": "Dictionaries (dict) are mutable: you can add, remove, and change key-value pairs after creation. Tuples, strings, and frozensets are all immutable.",
    "hint_1": "Mutable means the object can be changed after creation.",
    "hint_2": "Among the options, only one allows you to add or remove elements after creation.",
    "hint_3": "Dictionaries are mutable; the other three types are immutable."
  },
  {
    "quiz_id": "data_types_i_3",
    "topic": "data_types",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nx = (1,)\ny = (1)\nprint(type(x).__name__, type(y).__name__)\n```",
    "correct_answer": "tuple int",
    "explanation": "A trailing comma after the element makes (1,) a tuple. Without the comma, (1) is just the integer 1 in parentheses (grouping), not a tuple.",
    "hint_1": "Pay close attention to the comma.",
    "hint_2": "Parentheses alone do not create a tuple; the comma does.",
    "hint_3": "(1,) is a tuple, but (1) is just an integer."
  },
  {
    "quiz_id": "data_types_i_4",
    "topic": "data_types",
    "difficulty": "intermediate",
    "question_type": "short_answer",
    "question": "What Python data type would you use to store a collection of unique, unordered elements?",
    "correct_answer": "set",
    "explanation": "A set in Python is an unordered collection of unique elements. It automatically removes duplicates and supports mathematical set operations like union, intersection, and difference.",
    "hint_1": "It is a built-in collection type that enforces uniqueness.",
    "hint_2": "It is defined with curly braces {} or the built-in constructor of the same name.",
    "hint_3": "The type is called 'set'."
  },
  {
    "quiz_id": "data_types_i_5",
    "topic": "data_types",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nprint(bool(\"\"), bool(\" \"), bool(0), bool([]))\n```",
    "correct_answer": "False True False False",
    "explanation": "Empty strings, zero, and empty lists are falsy in Python. However, a string containing a single space (' ') is not empty, so it is truthy and evaluates to True.",
    "hint_1": "Python has specific rules about which values are considered 'falsy'.",
    "hint_2": "Empty containers and zero are falsy, but a space character makes a string non-empty.",
    "hint_3": "'' is falsy, ' ' is truthy, 0 is falsy, [] is falsy."
  },
  {
    "quiz_id": "data_types_a_1",
    "topic": "data_types",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\na = 256\nb = 256\nprint(a is b)\nc = 257\nd = 257\nprint(c is d)\n```",
    "correct_answer": "True\nFalse",
    "explanation": "CPython caches integers from -5 to 256, so a and b reference the same object (a is b is True). For 257, which is outside the cache range, Python creates separate objects for c and d (c is d is False). Note: this behavior is implementation-specific.",
    "hint_1": "The 'is' operator checks object identity, not value equality.",
    "hint_2": "CPython has an optimization for small integers that reuses the same object.",
    "hint_3": "Integers -5 to 256 are cached, so 256 is cached (True) but 257 is not (False)."
  },
  {
    "quiz_id": "data_types_a_2",
    "topic": "data_types",
    "difficulty": "advanced",
    "question_type": "multiple_choice",
    "question": "What does `isinstance(True, int)` return?",
    "options": {"A": "True", "B": "False", "C": "TypeError", "D": "None"},
    "correct_answer": "A",
    "explanation": "In Python, bool is a subclass of int. True and False are instances of bool, and since bool inherits from int, isinstance(True, int) returns True. In fact, True == 1 and False == 0.",
    "hint_1": "Consider the class hierarchy of Python's boolean type.",
    "hint_2": "bool is a subclass of int in Python.",
    "hint_3": "Since bool inherits from int, True is an instance of int, so it returns True."
  },
  {
    "quiz_id": "data_types_a_3",
    "topic": "data_types",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nd = {}\nd[1] = 'a'\nd[1.0] = 'b'\nd[True] = 'c'\nprint(d)\n```",
    "correct_answer": "{1: 'c'}",
    "explanation": "In Python, 1 == 1.0 == True and they all have the same hash value. Dictionary keys are matched by equality and hash, so 1, 1.0, and True are treated as the same key. The original key (1) is preserved but the value is overwritten each time, ending with 'c'.",
    "hint_1": "Think about how dictionary keys are compared.",
    "hint_2": "Keys that are equal and have the same hash are treated as the same key.",
    "hint_3": "1, 1.0, and True are all equal to each other, so only one key exists with the last assigned value."
  },
  {
    "quiz_id": "data_types_a_4",
    "topic": "data_types",
    "difficulty": "advanced",
    "question_type": "short_answer",
    "question": "In Python, what special method must an object implement to be usable as a dictionary key (besides __eq__)?",
    "correct_answer": "__hash__",
    "explanation": "To be used as a dictionary key, an object must be hashable, meaning it must implement __hash__() in addition to __eq__(). The hash value is used to determine the storage bucket, and __eq__ is used to resolve collisions. If an object defines __eq__ without __hash__, it becomes unhashable.",
    "hint_1": "Dictionaries use a specific data structure internally that requires a numeric value for each key.",
    "hint_2": "The internal data structure is a hash table.",
    "hint_3": "The method is __hash__, which computes a hash value for the object."
  },
  {
    "quiz_id": "data_types_a_5",
    "topic": "data_types",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nprint(type(1+2j).__name__)\nprint((1+2j).real)\nprint((1+2j).imag)\n```",
    "correct_answer": "complex\n1.0\n2.0",
    "explanation": "1+2j creates a complex number in Python. Its type name is 'complex'. The .real attribute returns the real part as a float (1.0), and .imag returns the imaginary part as a float (2.0).",
    "hint_1": "Python has a built-in type for numbers with both real and imaginary parts.",
    "hint_2": "The 'j' suffix denotes the imaginary component.",
    "hint_3": "The type is 'complex', and .real and .imag return float values."
  },
  {
    "quiz_id": "control_structures_b_1",
    "topic": "control_structures",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "Which keyword is used to check an additional condition after an `if` statement in Python?",
    "options": {"A": "else if", "B": "elseif", "C": "elif", "D": "otherwise"},
    "correct_answer": "C",
    "explanation": "Python uses 'elif' (short for 'else if') to check additional conditions. Unlike many other languages, Python does not use 'else if' as two separate words.",
    "hint_1": "It is a shortened form of two English words.",
    "hint_2": "It combines 'else' and 'if' into one keyword.",
    "hint_3": "The keyword is 'elif'."
  },
  {
    "quiz_id": "control_structures_b_2",
    "topic": "control_structures",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nfor i in range(3):\n    print(i, end=' ')\n```",
    "correct_answer": "0 1 2 ",
    "explanation": "range(3) generates the sequence 0, 1, 2. The loop prints each value followed by a space (due to end=' ') instead of a newline.",
    "hint_1": "range(3) starts from 0 by default.",
    "hint_2": "range(3) produces values 0, 1, 2 (not including 3).",
    "hint_3": "The output is 0, 1, and 2, each followed by a space."
  },
  {
    "quiz_id": "control_structures_b_3",
    "topic": "control_structures",
    "difficulty": "beginner",
    "question_type": "short_answer",
    "question": "What keyword is used to immediately exit a loop in Python?",
    "correct_answer": "break",
    "explanation": "The break statement immediately terminates the innermost loop it is in, and execution continues with the first statement after the loop.",
    "hint_1": "It is a single keyword that stops the loop.",
    "hint_2": "The word literally means to stop or interrupt something.",
    "hint_3": "The keyword is 'break'."
  },
  {
    "quiz_id": "control_structures_b_4",
    "topic": "control_structures",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nx = 7\nif x > 10:\n    print(\"big\")\nelif x > 5:\n    print(\"medium\")\nelse:\n    print(\"small\")\n```",
    "correct_answer": "medium",
    "explanation": "x is 7. The first condition (7 > 10) is False. The elif condition (7 > 5) is True, so 'medium' is printed. The else block is skipped.",
    "hint_1": "Evaluate each condition from top to bottom.",
    "hint_2": "7 is not greater than 10, but it is greater than 5.",
    "hint_3": "The elif branch executes, printing 'medium'."
  },
  {
    "quiz_id": "control_structures_b_5",
    "topic": "control_structures",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "How many times will the following loop execute?\n\n```python\ni = 0\nwhile i < 5:\n    i += 1\n```",
    "options": {"A": "4", "B": "5", "C": "6", "D": "Infinite"},
    "correct_answer": "B",
    "explanation": "The loop starts with i = 0 and increments i by 1 each iteration. It runs for i = 0, 1, 2, 3, 4 (five iterations). When i becomes 5, the condition i < 5 is False and the loop ends.",
    "hint_1": "Trace through the values of i at each step.",
    "hint_2": "The loop runs while i is 0, 1, 2, 3, and 4.",
    "hint_3": "That is 5 iterations total."
  },
  {
    "quiz_id": "control_structures_i_1",
    "topic": "control_structures",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nfor i in range(5):\n    if i == 3:\n        break\nelse:\n    print(\"done\")\nprint(i)\n```",
    "correct_answer": "3",
    "explanation": "The for-else construct runs the else block only if the loop completes without hitting a break. Here, break is triggered when i == 3, so the else block is skipped. After the loop, i retains its value of 3, which is printed.",
    "hint_1": "Python's for-else executes the else block only under a specific condition.",
    "hint_2": "The else block runs only if the loop finishes without encountering break.",
    "hint_3": "break is triggered at i=3, skipping the else. Then print(i) outputs 3."
  },
  {
    "quiz_id": "control_structures_i_2",
    "topic": "control_structures",
    "difficulty": "intermediate",
    "question_type": "multiple_choice",
    "question": "What is the purpose of the `continue` statement in a loop?",
    "options": {"A": "It exits the loop entirely", "B": "It skips the rest of the current iteration and moves to the next one", "C": "It restarts the loop from the beginning", "D": "It pauses the loop until a condition is met"},
    "correct_answer": "B",
    "explanation": "The continue statement skips the remaining code in the current loop iteration and jumps to the next iteration. Unlike break, it does not exit the loop.",
    "hint_1": "It affects only the current iteration, not the entire loop.",
    "hint_2": "It causes the loop to move on to the next iteration immediately.",
    "hint_3": "continue skips the rest of the current iteration and proceeds to the next."
  },
  {
    "quiz_id": "control_structures_i_3",
    "topic": "control_structures",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nresult = [x**2 for x in range(5) if x % 2 != 0]\nprint(result)\n```",
    "correct_answer": "[1, 9]",
    "explanation": "This list comprehension iterates over range(5) (0 to 4), filters for odd numbers (x % 2 != 0 gives 1 and 3), and squares them (1**2 = 1, 3**2 = 9). The result is [1, 9].",
    "hint_1": "The comprehension has a filter condition.",
    "hint_2": "Only odd numbers from 0-4 pass the filter: 1 and 3.",
    "hint_3": "Squaring 1 and 3 gives [1, 9]."
  },
  {
    "quiz_id": "control_structures_i_4",
    "topic": "control_structures",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nfor i in range(3):\n    for j in range(3):\n        if j == 1:\n            break\n        print(f\"{i},{j}\", end=' ')\n```",
    "correct_answer": "0,0 1,0 2,0 ",
    "explanation": "The outer loop runs for i = 0, 1, 2. For each i, the inner loop starts with j = 0 (prints i,0) and then j = 1 triggers break, exiting only the inner loop. So only j=0 is printed for each value of i.",
    "hint_1": "break only exits the innermost loop.",
    "hint_2": "Each iteration of the outer loop prints one value before the inner loop breaks.",
    "hint_3": "Only j=0 prints for each i, giving 0,0 1,0 2,0."
  },
  {
    "quiz_id": "control_structures_i_5",
    "topic": "control_structures",
    "difficulty": "intermediate",
    "question_type": "short_answer",
    "question": "What is the Python keyword used to create a placeholder in a block of code that does nothing?",
    "correct_answer": "pass",
    "explanation": "The pass statement is a null operation that does nothing. It is used as a placeholder where Python syntax requires a statement but no action is needed, such as in empty function bodies or empty loops.",
    "hint_1": "It is used when you need a syntactically valid statement but want to do nothing.",
    "hint_2": "It is often used in empty class or function definitions as a placeholder.",
    "hint_3": "The keyword is 'pass'."
  },
  {
    "quiz_id": "control_structures_a_1",
    "topic": "control_structures",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef gen():\n    for i in range(3):\n        yield i\n\ng = gen()\nprint(next(g))\nprint(next(g))\n\nfor val in g:\n    print(val, end=' ')\n```",
    "correct_answer": "0\n1\n2 ",
    "explanation": "The generator yields 0, 1, 2. The first next(g) returns 0, the second returns 1. The for loop picks up where the generator left off, yielding only 2. The generator remembers its state between calls.",
    "hint_1": "Generators maintain their state between calls to next().",
    "hint_2": "After two next() calls consuming 0 and 1, the for loop only gets the remaining value.",
    "hint_3": "next(g) gives 0, then 1. The for loop gets 2."
  },
  {
    "quiz_id": "control_structures_a_2",
    "topic": "control_structures",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ntry:\n    x = 1 / 0\nexcept ZeroDivisionError:\n    print(\"A\")\nexcept Exception:\n    print(\"B\")\nelse:\n    print(\"C\")\nfinally:\n    print(\"D\")\n```",
    "correct_answer": "A\nD",
    "explanation": "1/0 raises ZeroDivisionError, which is caught by the first except block (prints 'A'). The else block only runs when no exception occurs, so 'C' is skipped. The finally block always runs regardless of exceptions, so 'D' is printed.",
    "hint_1": "Consider which blocks execute when an exception is caught.",
    "hint_2": "The else block runs only when no exception occurs; finally always runs.",
    "hint_3": "The ZeroDivisionError is caught (A), else is skipped, finally runs (D)."
  },
  {
    "quiz_id": "control_structures_a_3",
    "topic": "control_structures",
    "difficulty": "advanced",
    "question_type": "multiple_choice",
    "question": "What does the walrus operator `:=` do in Python 3.8+?",
    "options": {"A": "It is an alias for the equality operator ==", "B": "It assigns a value to a variable as part of an expression", "C": "It creates a constant that cannot be reassigned", "D": "It performs type checking during assignment"},
    "correct_answer": "B",
    "explanation": "The walrus operator := (officially called 'assignment expression') assigns a value to a variable as part of an expression. This allows you to compute a value, assign it to a variable, and use it in the same expression, reducing code duplication.",
    "hint_1": "It combines two operations into one.",
    "hint_2": "It lets you assign and use a value in the same line.",
    "hint_3": "It assigns a value to a variable while returning that value for use in an expression."
  },
  {
    "quiz_id": "control_structures_a_4",
    "topic": "control_structures",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef func():\n    try:\n        return 1\n    finally:\n        return 2\n\nprint(func())\n```",
    "correct_answer": "2",
    "explanation": "The finally block always executes, even when a return statement is in the try block. The return in finally overrides the return in try. So func() returns 2, not 1.",
    "hint_1": "The finally block has a special relationship with return statements.",
    "hint_2": "finally executes even after a return in try.",
    "hint_3": "The return in finally overrides the return in try, so the function returns 2."
  },
  {
    "quiz_id": "control_structures_a_5",
    "topic": "control_structures",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nresult = []\nfor i in range(4):\n    match i % 3:\n        case 0:\n            result.append('fizz')\n        case 1:\n            result.append('one')\n        case _:\n            result.append('other')\nprint(result)\n```",
    "correct_answer": "['fizz', 'one', 'other', 'fizz']",
    "explanation": "Python's match-case (structural pattern matching, added in 3.10) checks i%3 for each i. i=0: 0%3=0 -> 'fizz'. i=1: 1%3=1 -> 'one'. i=2: 2%3=2 -> 'other'. i=3: 3%3=0 -> 'fizz'. Unlike switch in C/Java, there is no fall-through.",
    "hint_1": "match-case works like a switch statement without fall-through.",
    "hint_2": "Compute i % 3 for each value of i from 0 to 3.",
    "hint_3": "i%3 gives: 0, 1, 2, 0 which maps to 'fizz', 'one', 'other', 'fizz'."
  },
  {
    "quiz_id": "functions_b_1",
    "topic": "functions",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "Which keyword is used to define a function in Python?",
    "options": {"A": "function", "B": "func", "C": "def", "D": "define"},
    "correct_answer": "C",
    "explanation": "In Python, functions are defined using the 'def' keyword, followed by the function name and parentheses containing any parameters.",
    "hint_1": "It is a three-letter keyword.",
    "hint_2": "It is short for 'define'.",
    "hint_3": "The keyword is 'def'."
  },
  {
    "quiz_id": "functions_b_2",
    "topic": "functions",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef greet(name):\n    return f\"Hello, {name}!\"\n\nprint(greet(\"Alice\"))\n```",
    "correct_answer": "Hello, Alice!",
    "explanation": "The function greet() takes a name parameter and returns an f-string that inserts the name. Calling greet('Alice') returns 'Hello, Alice!' which is then printed.",
    "hint_1": "The f-string inserts the value of the variable name.",
    "hint_2": "{name} gets replaced with 'Alice'.",
    "hint_3": "The function returns 'Hello, Alice!'."
  },
  {
    "quiz_id": "functions_b_3",
    "topic": "functions",
    "difficulty": "beginner",
    "question_type": "short_answer",
    "question": "What value does a Python function return if it has no return statement?",
    "correct_answer": "None",
    "explanation": "If a Python function does not explicitly return a value (either no return statement or a bare return with no value), it implicitly returns None.",
    "hint_1": "It returns a special Python object that represents 'nothing'.",
    "hint_2": "This value is Python's way of representing the absence of a value.",
    "hint_3": "The value is None."
  },
  {
    "quiz_id": "functions_b_4",
    "topic": "functions",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef add(a, b=10):\n    return a + b\n\nprint(add(5))\nprint(add(5, 3))\n```",
    "correct_answer": "15\n8",
    "explanation": "The parameter b has a default value of 10. When add(5) is called, a=5 and b defaults to 10, giving 15. When add(5, 3) is called, a=5 and b=3, giving 8.",
    "hint_1": "The second parameter has a default value.",
    "hint_2": "If b is not provided, it uses 10. If b is provided, it uses the given value.",
    "hint_3": "add(5) = 5 + 10 = 15, add(5, 3) = 5 + 3 = 8."
  },
  {
    "quiz_id": "functions_b_5",
    "topic": "functions",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "What is the correct way to call a function named `calculate` with arguments 3 and 7?",
    "options": {"A": "calculate 3, 7", "B": "calculate(3, 7)", "C": "call calculate(3, 7)", "D": "calculate[3, 7]"},
    "correct_answer": "B",
    "explanation": "In Python, functions are called by writing the function name followed by parentheses containing the arguments. Square brackets are for indexing, and there is no 'call' keyword.",
    "hint_1": "Function calls use a specific type of bracket.",
    "hint_2": "Arguments are placed inside parentheses.",
    "hint_3": "The correct syntax is calculate(3, 7)."
  },
  {
    "quiz_id": "functions_i_1",
    "topic": "functions",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef make_counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\ncounter = make_counter()\nprint(counter())\nprint(counter())\nprint(counter())\n```",
    "correct_answer": "1\n2\n3",
    "explanation": "make_counter() returns the inner function increment, which forms a closure over the count variable. Each call to counter() increments and returns count. The nonlocal keyword allows modification of the enclosed variable.",
    "hint_1": "This is an example of a closure.",
    "hint_2": "The inner function remembers and modifies the count variable from the outer function.",
    "hint_3": "Each call increments count: 0->1, 1->2, 2->3."
  },
  {
    "quiz_id": "functions_i_2",
    "topic": "functions",
    "difficulty": "intermediate",
    "question_type": "multiple_choice",
    "question": "What does `*args` do in a function definition?",
    "options": {"A": "It unpacks a dictionary into keyword arguments", "B": "It collects extra positional arguments into a tuple", "C": "It makes all arguments required", "D": "It limits the function to accept only one argument"},
    "correct_answer": "B",
    "explanation": "*args collects any additional positional arguments passed to the function into a tuple. This allows the function to accept a variable number of positional arguments.",
    "hint_1": "The single asterisk relates to positional arguments.",
    "hint_2": "It gathers extra positional arguments into a collection.",
    "hint_3": "*args collects extra positional arguments into a tuple."
  },
  {
    "quiz_id": "functions_i_3",
    "topic": "functions",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nsquare = lambda x: x ** 2\nprint(list(map(square, [1, 2, 3, 4])))\n```",
    "correct_answer": "[1, 4, 9, 16]",
    "explanation": "The lambda defines an anonymous function that squares its input. map() applies this function to each element of the list [1, 2, 3, 4], producing [1, 4, 9, 16].",
    "hint_1": "map() applies a function to every element of an iterable.",
    "hint_2": "Each number in the list is squared: 1, 4, 9, 16.",
    "hint_3": "The result is [1, 4, 9, 16]."
  },
  {
    "quiz_id": "functions_i_4",
    "topic": "functions",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef append_to(element, target=[]):\n    target.append(element)\n    return target\n\nprint(append_to(1))\nprint(append_to(2))\n```",
    "correct_answer": "[1]\n[1, 2]",
    "explanation": "This is a classic Python gotcha. Default mutable arguments are evaluated once at function definition time, not at each call. The same list object is reused across calls, so 1 is appended first, then 2 is appended to the same list.",
    "hint_1": "There is a well-known issue with mutable default arguments in Python.",
    "hint_2": "The default list [] is created once and shared across all calls.",
    "hint_3": "Both calls modify the same list: first [1], then [1, 2]."
  },
  {
    "quiz_id": "functions_i_5",
    "topic": "functions",
    "difficulty": "intermediate",
    "question_type": "short_answer",
    "question": "What is the name of the concept where a function calls itself to solve a problem?",
    "correct_answer": "recursion",
    "explanation": "Recursion is a programming technique where a function calls itself with modified arguments to break down a problem into smaller subproblems. It requires a base case to prevent infinite recursion.",
    "hint_1": "It is a fundamental concept in computer science where a function references itself.",
    "hint_2": "The function solves a problem by calling a smaller version of itself.",
    "hint_3": "The concept is called recursion."
  },
  {
    "quiz_id": "functions_a_1",
    "topic": "functions",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"before\")\n        result = func(*args, **kwargs)\n        print(\"after\")\n        return result\n    return wrapper\n\n@decorator\ndef say_hello():\n    print(\"hello\")\n\nsay_hello()\n```",
    "correct_answer": "before\nhello\nafter",
    "explanation": "The @decorator syntax wraps say_hello with the decorator function. When say_hello() is called, it actually calls wrapper(), which prints 'before', then calls the original say_hello (printing 'hello'), then prints 'after'.",
    "hint_1": "The @ syntax modifies how the function behaves when called.",
    "hint_2": "The decorator wraps the function with additional behavior before and after.",
    "hint_3": "wrapper() prints 'before', calls the original function (prints 'hello'), then prints 'after'."
  },
  {
    "quiz_id": "functions_a_2",
    "topic": "functions",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda: i)\n\nprint([f() for f in funcs])\n```",
    "correct_answer": "[2, 2, 2]",
    "explanation": "This is a classic closure gotcha. The lambda captures the variable i by reference, not by value. By the time the lambdas are called, the loop has finished and i is 2. All three lambdas see the same final value of i.",
    "hint_1": "Closures capture variables by reference, not by value.",
    "hint_2": "All lambdas share the same variable i, which has its final loop value.",
    "hint_3": "After the loop, i is 2, so all three lambdas return 2."
  },
  {
    "quiz_id": "functions_a_3",
    "topic": "functions",
    "difficulty": "advanced",
    "question_type": "multiple_choice",
    "question": "What is the purpose of `functools.lru_cache`?",
    "options": {"A": "It limits the number of times a function can be called", "B": "It caches function results to avoid redundant computations", "C": "It forces a function to run in a separate thread", "D": "It logs every call to the function"},
    "correct_answer": "B",
    "explanation": "functools.lru_cache is a decorator that caches (memoizes) the results of function calls. If the function is called again with the same arguments, the cached result is returned instead of recomputing. LRU stands for 'Least Recently Used', describing the cache eviction strategy.",
    "hint_1": "LRU stands for 'Least Recently Used', a strategy used in a specific optimization technique.",
    "hint_2": "It stores previously computed results so the function does not have to recompute them.",
    "hint_3": "It caches return values for previously seen arguments."
  },
  {
    "quiz_id": "functions_a_4",
    "topic": "functions",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef f(x, y, /, z=3, *, w=4):\n    return x + y + z + w\n\nprint(f(1, 2))\nprint(f(1, 2, z=5, w=6))\n```",
    "correct_answer": "10\n14",
    "explanation": "The / separates positional-only parameters (x, y) from regular ones (z). The * separates regular parameters from keyword-only ones (w). f(1,2) uses defaults: 1+2+3+4=10. f(1,2,z=5,w=6) gives 1+2+5+6=14.",
    "hint_1": "The / and * symbols in the parameter list control how arguments can be passed.",
    "hint_2": "Parameters before / are positional-only. Parameters after * are keyword-only.",
    "hint_3": "First call: 1+2+3+4=10. Second call: 1+2+5+6=14."
  },
  {
    "quiz_id": "functions_a_5",
    "topic": "functions",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef apply_twice(func):\n    def wrapper(x):\n        return func(func(x))\n    return wrapper\n\n@apply_twice\ndef add_three(x):\n    return x + 3\n\nprint(add_three(7))\n```",
    "correct_answer": "13",
    "explanation": "The decorator apply_twice wraps add_three so that it is applied twice. Calling add_three(7) actually calls wrapper(7), which computes add_three(add_three(7)) = add_three(10) = 13.",
    "hint_1": "The decorator modifies the function to be applied twice in succession.",
    "hint_2": "The inner result is add_three(7) = 10, then add_three(10) = 13.",
    "hint_3": "7 + 3 = 10, then 10 + 3 = 13."
  },
  {
    "quiz_id": "lists_b_1",
    "topic": "lists",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "How do you create an empty list in Python?",
    "options": {"A": "list = ()", "B": "list = []", "C": "list = {}", "D": "list = <>"},
    "correct_answer": "B",
    "explanation": "Empty lists are created with square brackets []. Parentheses () create a tuple, curly braces {} create a dictionary, and <> is not valid Python syntax.",
    "hint_1": "Each bracket type creates a different data structure.",
    "hint_2": "Lists use a specific kind of bracket.",
    "hint_3": "Lists use square brackets: []."
  },
  {
    "quiz_id": "lists_b_2",
    "topic": "lists",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nfruits = ['apple', 'banana', 'cherry']\nprint(fruits[1])\n```",
    "correct_answer": "banana",
    "explanation": "Python uses zero-based indexing. fruits[0] is 'apple', fruits[1] is 'banana', and fruits[2] is 'cherry'.",
    "hint_1": "Python list indices start at 0.",
    "hint_2": "Index 1 refers to the second element.",
    "hint_3": "The second element is 'banana'."
  },
  {
    "quiz_id": "lists_b_3",
    "topic": "lists",
    "difficulty": "beginner",
    "question_type": "short_answer",
    "question": "What list method adds an element to the end of a list?",
    "correct_answer": "append",
    "explanation": "The append() method adds a single element to the end of a list. For example, my_list.append(5) adds 5 to the end of my_list.",
    "hint_1": "It is one of the most commonly used list methods.",
    "hint_2": "The method name means 'to add to the end'.",
    "hint_3": "The method is append()."
  },
  {
    "quiz_id": "lists_b_4",
    "topic": "lists",
    "difficulty": "beginner",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nnums = [10, 20, 30, 40, 50]\nprint(len(nums))\n```",
    "correct_answer": "5",
    "explanation": "The len() function returns the number of elements in a list. The list nums has 5 elements, so len(nums) returns 5.",
    "hint_1": "len() counts the number of elements.",
    "hint_2": "Count the items in the list.",
    "hint_3": "There are 5 elements: 10, 20, 30, 40, 50."
  },
  {
    "quiz_id": "lists_b_5",
    "topic": "lists",
    "difficulty": "beginner",
    "question_type": "multiple_choice",
    "question": "What does `nums[-1]` return for the list `nums = [5, 10, 15, 20]`?",
    "options": {"A": "5", "B": "10", "C": "15", "D": "20"},
    "correct_answer": "D",
    "explanation": "Negative indexing in Python counts from the end. Index -1 refers to the last element, -2 to the second-to-last, and so on. For nums = [5, 10, 15, 20], nums[-1] is 20.",
    "hint_1": "Negative indices count backwards from the end of the list.",
    "hint_2": "-1 refers to the very last element.",
    "hint_3": "The last element of [5, 10, 15, 20] is 20."
  },
  {
    "quiz_id": "lists_i_1",
    "topic": "lists",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nnums = [1, 2, 3, 4, 5]\nprint(nums[1:4])\nprint(nums[::2])\n```",
    "correct_answer": "[2, 3, 4]\n[1, 3, 5]",
    "explanation": "nums[1:4] slices from index 1 up to (not including) index 4, giving [2, 3, 4]. nums[::2] takes every 2nd element starting from the beginning, giving [1, 3, 5].",
    "hint_1": "List slicing uses the format [start:stop:step].",
    "hint_2": "The stop index is exclusive. The step determines which elements to include.",
    "hint_3": "nums[1:4] is [2,3,4] and nums[::2] takes every other element: [1,3,5]."
  },
  {
    "quiz_id": "lists_i_2",
    "topic": "lists",
    "difficulty": "intermediate",
    "question_type": "multiple_choice",
    "question": "What is the difference between `list.sort()` and `sorted(list)`?",
    "options": {"A": "There is no difference", "B": "sort() returns a new list, sorted() modifies in place", "C": "sort() modifies the list in place, sorted() returns a new list", "D": "sort() only works with numbers, sorted() works with any type"},
    "correct_answer": "C",
    "explanation": "list.sort() sorts the list in place and returns None. sorted() creates and returns a new sorted list, leaving the original unchanged. This is an important distinction for preserving original data.",
    "hint_1": "One modifies the original, the other creates a copy.",
    "hint_2": "Methods that modify in place typically return None in Python.",
    "hint_3": "sort() modifies in place (returns None), sorted() returns a new sorted list."
  },
  {
    "quiz_id": "lists_i_3",
    "topic": "lists",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nmatrix = [[1, 2], [3, 4], [5, 6]]\nflat = [x for row in matrix for x in row]\nprint(flat)\n```",
    "correct_answer": "[1, 2, 3, 4, 5, 6]",
    "explanation": "This nested list comprehension flattens the 2D list. The outer loop iterates over rows, the inner loop iterates over elements in each row. The order of the for clauses matches the order of equivalent nested for loops.",
    "hint_1": "The comprehension has two for clauses that flatten the nested structure.",
    "hint_2": "The outer for iterates over rows, the inner for iterates over elements within each row.",
    "hint_3": "Each element from each row is collected in order: 1, 2, 3, 4, 5, 6."
  },
  {
    "quiz_id": "lists_i_4",
    "topic": "lists",
    "difficulty": "intermediate",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\na = [1, 2, 3]\nb = a[:]\nb.append(4)\nprint(a)\nprint(b)\n```",
    "correct_answer": "[1, 2, 3]\n[1, 2, 3, 4]",
    "explanation": "a[:] creates a shallow copy of the list. b is a new list with the same elements. Modifying b (appending 4) does not affect a because they are separate list objects.",
    "hint_1": "The [:] syntax creates a copy of the list.",
    "hint_2": "Unlike b = a, which shares the same list, b = a[:] creates an independent copy.",
    "hint_3": "a stays [1,2,3] because b is a separate copy; b becomes [1,2,3,4]."
  },
  {
    "quiz_id": "lists_i_5",
    "topic": "lists",
    "difficulty": "intermediate",
    "question_type": "short_answer",
    "question": "What list method removes and returns the element at a given index (defaulting to the last element)?",
    "correct_answer": "pop",
    "explanation": "The pop() method removes and returns the element at the specified index. If no index is given, it removes and returns the last element. For example, my_list.pop(0) removes and returns the first element.",
    "hint_1": "It both removes and returns an element.",
    "hint_2": "It is the opposite of 'push' in stack terminology.",
    "hint_3": "The method is pop()."
  },
  {
    "quiz_id": "lists_a_1",
    "topic": "lists",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\na = [1, 2, 3]\nb = [a] * 3\na.append(4)\nprint(b)\n```",
    "correct_answer": "[[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]",
    "explanation": "[a] * 3 creates a list containing three references to the same list object a. When a is modified by appending 4, all three references in b reflect the change because they all point to the same underlying list.",
    "hint_1": "Multiplying a list with * replicates references, not copies.",
    "hint_2": "All three elements of b are the same object as a.",
    "hint_3": "Since all three are the same list, appending to a shows up in all three."
  },
  {
    "quiz_id": "lists_a_2",
    "topic": "lists",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nnums = [1, 2, 3, 4, 5]\nnums[1:3] = [20, 30, 40]\nprint(nums)\n```",
    "correct_answer": "[1, 20, 30, 40, 4, 5]",
    "explanation": "Slice assignment replaces the elements at indices 1 and 2 (values 2, 3) with the new elements [20, 30, 40]. The replacement can have a different length than the slice being replaced, which changes the list length.",
    "hint_1": "Slice assignment can replace a range of elements with a different number of elements.",
    "hint_2": "Elements at positions 1 and 2 are replaced by three new elements.",
    "hint_3": "[1, 2, 3, 4, 5] becomes [1, 20, 30, 40, 4, 5] after replacing indices 1:3 with [20, 30, 40]."
  },
  {
    "quiz_id": "lists_a_3",
    "topic": "lists",
    "difficulty": "advanced",
    "question_type": "multiple_choice",
    "question": "What is the time complexity of checking if an element exists in a Python list using `in`?",
    "options": {"A": "O(1)", "B": "O(log n)", "C": "O(n)", "D": "O(n log n)"},
    "correct_answer": "C",
    "explanation": "Checking membership with 'in' on a list requires a linear scan because lists are not ordered by value or hashed. In the worst case, every element must be checked, giving O(n) time complexity. For O(1) lookups, use a set or dictionary.",
    "hint_1": "Lists do not have any special structure that allows fast lookups.",
    "hint_2": "The list must be scanned element by element.",
    "hint_3": "A linear scan is O(n)."
  },
  {
    "quiz_id": "lists_a_4",
    "topic": "lists",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\ndef mystery(lst):\n    return lst[0] if len(lst) == 1 else lst[0] + mystery(lst[1:])\n\nprint(mystery([1, 2, 3, 4]))\n```",
    "correct_answer": "10",
    "explanation": "This is a recursive function that sums all elements of a list. It returns the first element if the list has one element (base case), otherwise it adds the first element to the recursive sum of the rest. 1 + (2 + (3 + 4)) = 10.",
    "hint_1": "Trace through the recursive calls.",
    "hint_2": "The function adds the first element to the result of processing the rest.",
    "hint_3": "mystery([1,2,3,4]) = 1 + mystery([2,3,4]) = 1 + 2 + 3 + 4 = 10."
  },
  {
    "quiz_id": "lists_a_5",
    "topic": "lists",
    "difficulty": "advanced",
    "question_type": "code_output",
    "question": "What is the output of the following code?\n\n```python\nfrom itertools import zip_longest\n\na = [1, 2, 3]\nb = ['a', 'b']\nresult = list(zip_longest(a, b, fillvalue='?'))\nprint(result)\n```",
    "correct_answer": "[(1, 'a'), (2, 'b'), (3, '?')]",
    "explanation": "zip_longest pairs elements from both iterables, filling in the specified fillvalue when the shorter iterable is exhausted. Since b is shorter, its missing third element is replaced with '?'.",
    "hint_1": "zip_longest handles iterables of different lengths.",
    "hint_2": "When one iterable runs out, the fill value is used in its place.",
    "hint_3": "The third pair gets '?' for the missing element from b: (3, '?')."
  }
]
